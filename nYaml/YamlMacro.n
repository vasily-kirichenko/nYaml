using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.ActivePatterns;
using Nemerle.Extensions;
using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using SharpYaml;
using SharpYaml.Serialization;
using SharpYaml.Serialization.Serializer;
using Utils;
using Macros.Core;

namespace nYaml {
    /*
Following code:
    
[assembly: Yaml(Y4, <#
Foo: 1
	Person:
	    Name: "bar"
	    Age: 30
	    Addr: http://1.com/
#>)];    
    
generates code like this:
	        
public class Yaml {
    mutable _Foo: int = 1;
    _Person: Person_Type = Person_Type();
	    
    public Foo: int { get { _Foo }}
    public Person: Person_Type { get { _Person }}
	    
    public class Person_Type {
        mutable _Name: string = "bar";
        mutable _Age: int = 30;
        mutable _Addr: Uri = Uri("http://1.com");
	            
        public Name: string { get { _Name }}
        public Age: int { get { _Age }}
        public Addr: Uri { get { _Addr }}
    }
}*/

    [MacroUsage (MacroPhase.BeforeInheritance, MacroTargets.Assembly)]
	public macro Yaml(name: PExpr, text: PExpr)
	{
		def typer = Macros.ImplicitCTX();
		YamlImpl.Transform(typer, name, text);
	}
	
	[Show]
    variant Scalar {
	    | Int { v: int }
	    | String { v: string }
	    | TimeSpan { v: System.TimeSpan }
	    | Bool { v: bool }
	    | Uri { v: System.Uri }
	    | Float { v: double; }
    
        public static ParseStr(str: string): Scalar {
            active match (str) {  
            | ValueParser.TimeSpan(x) => Scalar.TimeSpan(x)
            | ValueParser.Uri(x) => Scalar.Uri(x)
            | x => String(x)
            }
        }
        
	    public static FromObj(obj: object): Scalar {
	        match (obj) {
            | null => String("")
            | b is System.Boolean => Bool(b)
            | i is System.Int32 => Int(i)
            | d is System.Double => Float(d)
            | s is System.String => Scalar.ParseStr(s)
            | t => throw Exception($"Unknown type $(t.GetType().ToString())")
            }
        }
            
        public BoxedValue: object {
            get {
                match (this) {
                | Int(v) with x = v : object
                | String(x)
                | Bool(x)
                | TimeSpan(x)
                | Uri(x)
                | Float(x) => x
                }
            }
        }

        public ValueAsExpr: PExpr {
            get {
                match (this) {
                | Int(x) => <[ $x ]>
                | String(x) => <[ $x ]>
                | Bool(x) => <[ $x ]>
                | TimeSpan(x) => <[ System.TimeSpan.FromMilliseconds($(x.TotalMilliseconds)) ]>
                | Uri(x) => <[ Uri($(x.OriginalString)) ]>
                | Float(x) => <[ $x ]>
                }
            }
        }
        
        public UnderlyingType(builder: TypeBuilder): PExpr { 
            PExpr.FromQualifiedIdentifier(builder.Manager, BoxedValue.GetType().FullName)
        }
    }    
        
    [Show]
    variant Node {
        | Scal { v: Scalar }
        | List { children: list[Node] }
        | Map { nodes: list[string * Node] }
    }
        
    module Builder {
        public Transform (builder: TypeBuilder, name: option[string], node: Node): option[PExpr]  {
            match (name, node) {
            | (Some(name), Scal(x)) => TransformScalar(builder, name, x); None()
            | (_, Map(m)) => TransformMap(builder, name, m)
            | (Some(name), List(l)) => Some(TransformList(builder, name, l))
            | (None, _) => throw Exception("Only Maps are allowed at the root level.")
            }
        }
        
        TransformScalar(builder: TypeBuilder, name: string, node: Scalar): void {
            def fieldType = node.UnderlyingType(builder);
            def fieldName = $"_$name";
            def defaultValue = node.ValueAsExpr;
            builder.Define(<[decl: private mutable $(fieldName: usesite): $fieldType = $defaultValue; ]>);
            builder.Define(<[decl: public $(name: usesite): $fieldType { get { this.$(fieldName: usesite) } } ]>);
        }
        
        TransformChildren(builder: TypeBuilder, children: list[string * Node]): void {
            foreach ((name, child) in children)
                _ =  Transform(builder, Some(name), child)
        }
        
        TransformMap(builder: TypeBuilder, name: option[string], children: list[string * Node]): option[PExpr] {
            match (name) {
            | Some (name) =>
                def typeName = Macros.NewSymbol(name);
                Message.Hint($"About to define $typeName...");
                def mapTy = builder.DefineNestedType(<[decl: public sealed class $typeName { } ]>);
                TransformChildren(mapTy, children);
                mapTy.Compile();
                def mapFieldName = $"_$name";
                def typeExpr = <[ $(typeName: name) ]>;
                builder.Define(<[decl: private $(mapFieldName: usesite): $typeExpr = $(mapTy.Name: usesite)(); ]>);
                builder.Define(<[decl: public $(name: usesite): $typeExpr { get { this.$(mapFieldName: usesite) } } ]>);
                Some(typeExpr);
            | None => 
                TransformChildren(builder, children);
                None();
            }
        }
        
        TransformList(builder: TypeBuilder, name: string, children: list[Node]): PExpr {
            def elementTypeExprs = children.Map(x => {
                match (x: Node) {
                | Scal(x) => Some(x.UnderlyingType(builder))
                | Map(m) => TransformMap(builder, None(), m)
                | List(l) => Some(TransformList(builder, (name + "_Items"), l))
                }
            });
            
            def (elements, elementType) =
                match (elementTypeExprs.Distinct().NToList()) {
                | [Some(ty)] => (elementTypeExprs, ty)
                | [None] =>
                
                    def headChildren = match (children.Head) { | Map(m) => m | _ => throw Exception("expected a sequence of maps.") };
                    
                    def mapTy = Transform ProvidedTypeDefinition(name + "_Item_Type", Some typeof<obj>, HideObjectMethods = true,
                                                       IsErased = false, SuppressRelocation = false)

                    
                    TransformChildren(builder, headChildren);
                    let childTypes, childInits = foldChildren readOnly headChildren

                    let mapTy = ProvidedTypeDefinition(name + "_Item_Type", Some typeof<obj>, HideObjectMethods = true,
                                                       IsErased = false, SuppressRelocation = false)

                    let ctr = ProvidedConstructor([], InvokeCode = (fun [me] -> childInits me))
                    mapTy.AddMembers (ctr :> MemberInfo :: childTypes)
                    mapTy.AddMember eventField
                    mapTy.AddMember event
                    [{ MainType = Some (mapTy :> _)
                       Types = [mapTy :> MemberInfo]
                       Init = fun _ -> Expr.NewObject(ctr, []) }],
                    mapTy :> _
                | types -> failwithf "List cannot contain elements of heterogeneous types (attempt to mix types: %A)."
                                     (types |> List.map (Option.map (fun x -> x.Name)))
                }

            //let propType = ProvidedTypeBuilder.MakeGenericType(typedefof<IList<_>>, [elementType])
            //let ctrType = ProvidedTypeBuilder.MakeGenericType(typedefof<seq<_>>, [elementType])
        
            //let listCtr =
            //    let meth = typeof<Helper>.GetMethod("CreateResizeArray")
            //    ProvidedTypeBuilder.MakeGenericMethod(meth, [elementType])
        
            //let childTypes = elements |> List.collect (fun x -> x.Types)

            //let initValue ty me =
            //    Expr.Coerce(
            //        Expr.Call(listCtr, [Expr.Coerce(Expr.NewArray(elementType, elements |> List.map (fun x -> x.Init me)), ctrType)]),
            //        ty)

            //if generateField then
            //    let fieldType = ProvidedTypeBuilder.MakeGenericType(typedefof<ResizeArray<_>>, [elementType])
            //    let field = ProvidedField("_" + name, fieldType)
            
            //    let prop = 
            //        ProvidedProperty (name, propType, IsStatic=false, GetterCode = 
            //            fun [me] -> Expr.Coerce(Expr.FieldGet(me, field), propType))

            //    if not readOnly then 
            //        prop.SetterCode <- fun [me; v] -> Expr.FieldSet(me, field, Expr.Coerce(Expr.Call(listCtr, [Expr.Coerce(v, ctrType)]), fieldType))

            //    { MainType = Some fieldType
            //      Types = childTypes @ [field :> MemberInfo; prop :> MemberInfo]
            //      Init = fun me -> Expr.FieldSet(me, field, initValue fieldType me) }
            //else
            //    { MainType = Some propType
            //      Types = childTypes
            //      Init = initValue propType }
       }

    }
	
	module YamlImpl {
		public Transform(typer: Typer, typeName: PExpr, text: PExpr): PExpr {
		    match (typeName, text) {
		    | (<[ $(PExpr.Ref(typeName)) ]>, <[ $(text: string) ]>) => { 
		    def settings = SerializerSettings() <- 
		        { EmitDefaultValues = true; 
		          EmitTags = false; 
		          SortKeyForMapping = false 
		        };
                def serializer = Serializer(settings);
                def node = serializer.Deserialize(StringReader(text));
            
                def loop(n: object) {
                    Message.Hint($"Node: $n, type = $(n.GetType())");
                    match (n) {
                    | l is List[object] => Node.List (l.Map(loop))
                    | d is Dictionary[object, object] => 
                        Node.Map (d.NToList().Choose(p => {
                            match (p.Key) {
                            | key is string => Some(key, loop(p.Value))
                            | _ => None()
                            }}))
                    | scalar =>
                        Node.Scal (Scalar.FromObj(scalar))
                    }
                }
            
                def node = loop(node);
                def nodeAsString = node.ToString();
                Util.locate(typeName.Location,
		        {
		            def builder = typer.Env.Define(<[ decl: public sealed class $typeName {} ]>);
		            builder.Define(<[ decl: public AstAsString: string { get { $nodeAsString }} ]>);
		            Builder.Transform(builder, None(), node);
		            builder.Compile();
		        });
		        <[]>
			  }
			| _ => Message.FatalError($"Name must be a symbol and text must be a string, but got $(typeName.GetType().ToString()), $(text.ToString())")
		    }
		}
	}
}
