using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.ActivePatterns;
using Nemerle.Extensions;
using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using SharpYaml;
using SharpYaml.Serialization;
using SharpYaml.Serialization.Serializer;
using Utils;
using Macros.Core;

namespace nYaml {
    /*
Following code:
    
[assembly: Yaml(Y4, <#
Foo: 1
	Person:
	    Name: "bar"
	    Age: 30
	    Addr: http://1.com/
#>)];    
    
generates code like this:
	        
public class Yaml {
    mutable _Foo: int = 1;
	_Person: Person_Type = Person_Type();
	    
	public Foo: int { get { _Foo }}
	public Person: Person_Type { get { _Person }}
	    
	public class Person_Type {
	    mutable _Name: string = "bar";
	    mutable _Age: int = 30;
	    mutable _Addr: Uri = Uri("http://1.com");
	            
	    public Name: string { get { _Name }}
	    public Age: int { get { _Age }}
	    public Addr: Uri { get { _Addr }}
	}
}*/

    [MacroUsage (MacroPhase.BeforeInheritance, MacroTargets.Assembly)]
	public macro Yaml(name: PExpr, text: PExpr)
	{
		def typer = Macros.ImplicitCTX();
		YamlImpl.Transform(typer, name, text);
	}
	
	[Show]
    variant Scalar {
	    | Int { v: int }
	    | String { v: string }
	    | TimeSpan { v: System.TimeSpan }
	    | Bool { v: bool }
	    | Uri { v: System.Uri }
	    | Float { v: double; }
    
        public static ParseStr(str: string): Scalar {
            active match (str) {
            | ValueParser.TimeSpan(x) => Scalar.TimeSpan(x)
            | ValueParser.Uri(x) => Scalar.Uri(x)
            | x => String(x)
            }
        }
        
	    public static FromObj(obj: object): Scalar {
	        match (obj) {
            | null => String("")
            | b is System.Boolean => Bool(b)
            | i is System.Int32 => Int(i)
            | d is System.Double => Float(d)
            | s is System.String => Scalar.ParseStr(s)
            | t => throw Exception($"Unknown type $(t.GetType().ToString())")
            }
        }
            
        public UnderlyingType: Type {
            get { BoxedValue.GetType() }
        }

        public BoxedValue: object {
            get {
                match (this) {
                | Int(v) with x = v : object
                | String(x)
                | Bool(x)
                | TimeSpan(x)
                | Uri(x)
                | Float(x) => x
                }
            }
        }
    }    
        
    [Show]
    variant Node {
        | Scal { v: Scalar }
        | List { children: list[Node] }
        | Map { nodes: list[string * Node] }
    }
        
    module Builder {
        public Transform (builder: TypeBuilder, name: option[string], node: Node): void  {
            match (name, node) {
            | (Some(name), Scal(x)) => TransformScalar(builder, name, x)
            | (_, Map(m)) => TransformMap(builder, name, m)
            //| (Some(name), List(l)) => TransformList(name, true, l)
            | _ => ()
            //| (None, _) => throw Exception("Only Maps are allowed at the root level.")
            }
        }
        
        TransformScalar(builder: TypeBuilder, name: string, node: Scalar): void {
            def fieldType = PExpr.FromQualifiedIdentifier(builder.Manager, node.BoxedValue.GetType().FullName);
            def fieldName = $"_$name";
            def defaultValue = node.BoxedValue.ToString();
            builder.Define(<[decl: private mutable $(fieldName: usesite): $fieldType = $(defaultValue: usesite); ]>);
            builder.Define(<[decl: public $(name: usesite): $fieldType { get { this.$(fieldName: usesite) } } ]>);
        }
        
        TransformChildren(builder: TypeBuilder, children: list[string * Node]): void {
            foreach ((name, child) in children)
                Transform(builder, Some(name), child);
        }
        
        TransformMap(builder: TypeBuilder, name: option[string], children: list[string * Node]): void {
            match (name) {
            | Some (name) =>
                def typeName = Macros.NewSymbol(name);
                Message.Hint($"About to define $typeName...");
                def mapTy = builder.DefineNestedType(<[decl: public sealed class $typeName { } ]>);
                TransformChildren(mapTy, children);
                mapTy.Compile();
                def mapFieldName = $"_$name";
                builder.Define(<[decl: private $(mapFieldName: usesite): $(typeName: name) = $(mapTy.Name: usesite)(); ]>);
                builder.Define(<[decl: public $(mapTy.Name: usesite): $(typeName: name) { get { this.$(mapFieldName: usesite) } } ]>);
            | None => 
                TransformChildren(builder, children)
            }
        }
    }
	
	module YamlImpl {
		public Transform(typer: Typer, typeName: PExpr, text: PExpr): PExpr {
		    match (typeName, text) {
		    | (<[ $(PExpr.Ref(typeName)) ]>, <[ $(text: string) ]>) => { 
		    def settings = SerializerSettings() <- 
		        { EmitDefaultValues = true; 
		          EmitTags = false; 
		          SortKeyForMapping = false 
		        };
                def serializer = Serializer(settings);
                def node = serializer.Deserialize(StringReader(text));
            
                def loop(n: object) {
                    Message.Hint($"Node: $n, type = $(n.GetType())");
                    match (n) {
                    | l is List[object] => Node.List (l.Map(loop))
                    | d is Dictionary[object, object] => 
                        Node.Map (d.NToList().Choose(p => {
                            match (p.Key) {
                            | key is string => Some(key, loop(p.Value))
                            | _ => None()
                            }}))
                    | scalar =>
                        Node.Scal (Scalar.FromObj(scalar))
                    }
                }
            
                def node = loop(node);
                def nodeAsString = node.ToString();
                Util.locate(typeName.Location,
		        {
		            def builder = typer.Env.Define(<[ decl: public sealed class $typeName {} ]>);
		            builder.Define(<[ decl: public AstAsString: string { get { $nodeAsString }} ]>);
		            Builder.Transform(builder, None(), node);
		            builder.Compile();
		        });
		        <[]>
			  }
			| _ => Message.FatalError($"Name must be a symbol and text must be a string, but got $(typeName.GetType().ToString()), $(text.ToString())")
		    }
		}
	}
}
