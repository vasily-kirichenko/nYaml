using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.ActivePatterns;
using Nemerle.Extensions;
using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using SharpYaml;
using SharpYaml.Serialization;
using SharpYaml.Serialization.Serializer;
using Utils;
using Macros.Core;
using System.Diagnostics;

namespace nYaml {
    /*
Following code:
    
[assembly: Yaml(Y4, <#
Foo: 1
	Person:
	    Name: "bar"
	    Age: 30
	    Addr: http://1.com/
#>)];    
    
generates code like this:
	        
public class Yaml {
    mutable _Foo: int = 1;
    _Person: Person_Type = Person_Type();
	    
    public Foo: int { get { _Foo }}
    public Person: Person_Type { get { _Person }}
	    
    public class Person_Type {
        mutable _Name: string = "bar";
        mutable _Age: int = 30;
        mutable _Addr: Uri = Uri("http://1.com");
	            
        public Name: string { get { _Name }}
        public Age: int { get { _Age }}
        public Addr: Uri { get { _Addr }}
    }
}*/

    [MacroUsage (MacroPhase.BeforeInheritance, MacroTargets.Assembly)]
	public macro Yaml(name: PExpr, text: PExpr)
	{
		def typer = Macros.ImplicitCTX();
		_ = YamlImpl.Transform(typer, name, text)
	}
	
	module YamlImpl {
		public Transform(typer: Typer, typeName: PExpr, txt: PExpr): PExpr {
		    //_ = Debugger.Launch();
		    match (typeName, txt) {
		    | (<[ $(PExpr.Ref(typeName)) ]>, <[ $(text: string) ]>) => { 
		        def serializerBackend = ObjectSerializerBackend(txt.Location);
		        def settings = SerializerSettings() <- 
		        { EmitDefaultValues = true; 
		          EmitTags = false; 
		          SortKeyForMapping = false;
		          ObjectSerializerBackend = serializerBackend
		        };
                def serializer = Serializer(settings);
                def node = serializer.Deserialize(StringReader(text));
            
                def loop(n: object): Node {
                    //Message.Hint($"Node: $n: $(n.GetType().Name)");
                    def r = serializerBackend.Ranges.TryFind(n);
                    match (n) {
                    | l is List[object] => Node.List(l.Map(loop), r)
                    | d is Dictionary[object, object] =>
                        Node.Map (d.NToList().Choose(p => {
                            match (p.Key) {
                            | key is string => Some(key, loop(p.Value))
                            | _ => None()
                            }
                        }), r)
                    | s => Node.Scal (Scalar.Infer(s), r)
                    }
                }
            
                def node = loop(node);
                def nodeAsString = node.ToString();
                Util.locate(typeName.Location,
		        {
		            def builder = typer.Env.Define(<[ decl: public sealed class $typeName {} ]>);
		            builder.Define(<[ decl: public AstAsString: string { get { $nodeAsString }} ]>);
		            _ = Builder.Transform(builder, None(), node);
		            builder.Compile();
		        });
		        <[]>
			  }
			| _ => Message.FatalError($"Name must be a symbol and text must be a string, but got $(typeName.GetType()), $(txt.GetType())")
		    }
		}
	}
	
	[Show]
    variant Scalar {
	    | Int { v: int }
	    | String { v: string }
	    | TimeSpan { v: System.TimeSpan }
	    | Bool { v: bool }
	    | Uri { v: System.Uri }
	    | Float { v: double; }
    
        public static ParseStr(str: string): Scalar {
            active match (str) {  
            | ValueParser.TimeSpan(x) => Scalar.TimeSpan(x)
            | ValueParser.Uri(x) => Scalar.Uri(x)
            | ValueParser.Bool(x) => Scalar.Bool(x)
            | x => String(x)
            }
        }
        
	    public static Infer(obj: object): Scalar {
	        match (obj) {
            | null => String("")
            | b is System.Boolean => Bool(b)
            | i is System.Int32 => Int(i)
            | d is System.Double => Float(d)
            | s is System.String => Scalar.ParseStr(s)
            | t => throw Exception($"Unknown type $(t.GetType().ToString())")
            }
        }
            
        public BoxedValue: object {
            get {
                match (this) {
                | Int(v) with x = v : object
                | String(x)
                | Bool(x)
                | TimeSpan(x)
                | Uri(x)
                | Float(x) => x
                }
            }
        }

        public ValueAsExpr: PExpr {
            get {
                match (this) {
                | Int(x) => <[ $x ]>
                | String(x) => <[ $x ]>
                | Bool(x) => <[ $x ]>
                | TimeSpan(x) => <[ System.TimeSpan.FromMilliseconds($(x.TotalMilliseconds)) ]>
                | Uri(x) => <[ Uri($(x.OriginalString)) ]>
                | Float(x) => <[ $x ]>
                }
            }
        }
        
        public UnderlyingType(builder: TypeBuilder): PExpr { 
            PExpr.FromQualifiedIdentifier(builder.Manager, BoxedValue.GetType().FullName)
        }
    }    
        
    [Show]
    variant Node {
        | Scal { v: Scalar; r: option[Range] }
        | List { elements: list[Node]; r: option[Range] }
        | Map { nodes: list[string * Node]; r: option[Range] }
        Location: option[Range] {
            get {
                match (this) {
                | Scal(_, x) => x
                | List(_, x) => x
                | Map(_, x) => x
                }
            }
        }
        public GetLocation(parentBuilder: TypeBuilder): Location {
            Location
                .Map(loc => Location(parentBuilder.Location.FileIndex, loc.Begin, loc.End))
                .WithDefault(parentBuilder.Location)
        }
    }
    
    variant ListType {
        | Scalars
        | Maps
    }
        
    module Builder {
        public Transform (tb: TypeBuilder, name: option[string], node: Node): option[PExpr]  {
            match (name, node) {
            | (Some(name), Scal(_, _) as scal) => TransformScalar(tb, name, scal); None()
            | (_, Map(_, _) as m) => TransformMap(tb, name, m)
            | (Some(name), List(_,_) as l) => TransformList(tb, name, l); None()
            | (None, _) => Message.FatalError(tb.Location, "Only Maps are allowed at the root level.")
            }
        }
        
        TransformScalar(tb: TypeBuilder, name: string, node: Node.Scal): void {
            def fieldType = node.v.UnderlyingType(tb);
            def fieldName = $"_$name";
            def defaultValue = node.v.ValueAsExpr;
            tb.Define(<[decl: mutable $(fieldName: usesite): $fieldType = $defaultValue; ]>);
            tb.Define(<[decl: public $(name: usesite): $fieldType { 
                                       get { $(fieldName: usesite) } 
                                       set { $(fieldName: usesite) = value }
                                   } ]>);
        }
        
        TransformChildren(tb: TypeBuilder, children: list[string * Node]): void {
            foreach ((name, child) in children)
                _ =  Transform(tb, Some(name), child)
        }
        
        TransformMap(tb: TypeBuilder, name: option[string], map: Node.Map): option[PExpr] {
            match (name) {
            | Some (name) =>
                def typeName = Macros.NewSymbol(name);
                def mapTy = tb.DefineNestedType(<[decl: public sealed class $typeName { } ]>);
                TransformChildren(mapTy, map.nodes);
                mapTy.Compile();
                def mapFieldName = $"_$name";
                def typeExpr = <[ $(typeName: name) ]>;
                tb.Define(<[decl: mutable $(mapFieldName: usesite): $typeExpr = $(mapTy.Name: usesite)(); ]>);
                tb.Define(<[decl: public $(name: usesite): $typeExpr { 
                                           get { $(mapFieldName: usesite) } 
                                           set { $(mapFieldName: usesite) = value }
                                       } ]>);
                Some(typeExpr);
            | None => 
                TransformChildren(tb, map.nodes);
                None();
            }
        }
        
        TransformList(tb: TypeBuilder, name: string, list: Node.List): void {
            //Debugger.Launch();
            def childrenNodes = list.elements;
            
            when (childrenNodes.Exists(x => !(x is Node.Scal))) {
                Message.Error(tb.Location, "List of scalars are supported only.");
                Message.Error(list.GetLocation(tb), "List of scalars are supported only.");
            }
            
            def scalarChildren = childrenNodes.OfType.[Node.Scal]().Map(x => x.v);
                
            def (elemType, elemValues) =
                if (scalarChildren.Map(x => x.BoxedValue.GetType()).Distinct().Count() > 1) {
                    foreach(loc in [tb.Location, list.GetLocation(tb)])
                        Message.Warning(loc, "Because the list contains values of heterogeneous types, it's generated as List[object]");
                    (<[ object ]>,
                     scalarChildren.Map(x => <[ $(x.ValueAsExpr) : object ]>))
                }
                else {
                    (scalarChildren.Head.UnderlyingType(tb), scalarChildren.Map(_.ValueAsExpr))
                };
                
            def listFieldName = $"_$name";
            
            tb.Define(<[decl: $(listFieldName: usesite): System.Collections.Generic.List.[$elemType] = 
                                  System.Collections.Generic.List.[$elemType]([..$elemValues]); ]>);    
            
            tb.Define(<[decl: public $(name: usesite): System.Collections.Generic.List.[$elemType] { 
                                       get { $(listFieldName: usesite) }
                              } ]>);
                              
       }
    }
    
    module ListBuilder {
        
    }
}