using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.ActivePatterns;
using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using YamlDotNet;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.Serializer;
using Utils;
using Macros.Core;

namespace nYaml {
    [MacroUsage (MacroPhase.BeforeInheritance, MacroTargets.Assembly)]
	public macro Yaml(name: PExpr, text: PExpr)
	//syntax("yaml", name, "of", text)
	{
		def typer = Macros.ImplicitCTX();
		YamlImpl.Transform(typer, name, text);
	}
	
	[Show]
	variant Scalar {
	    | Int { v: int }
	    | String { v: string }
	    | TimeSpan { v: System.TimeSpan }
	    | Bool { v: bool; [RecordIgnore] foo: int }
	    | Uri { v: System.Uri }
	    | Float { 
	        v: double;
	        public override ToString(): string { "foo" }
	      }
    
        public static ParseStr(str: string): Scalar {
            active match (str) {
            | ValueParser.TimeSpan(x) => Scalar.TimeSpan(x)
            | ValueParser.Uri(x) => Scalar.Uri(x)
            | x => String(x)
            }
        }
        
	    public static FromObj(obj: object): Scalar {
	        match (obj) {
            | null => String("")
            | b is System.Boolean => Bool(b)
            | i is System.Int32 => Int(i)
            | d is System.Double => Float(d)
            | s is System.String => Scalar.ParseStr(s)
            | t => throw Exception($"Unknown type $(t.GetType().ToString())")
            }
        }
            
        public UnderlyingType: Type {
            get {
                match (this) {
                | Int(v) with x = v : object
                | String(x)
                | Bool(x)
                | TimeSpan(x)
                | Uri(x)
                | Float(x) => x.GetType()
                }
            }
        }
        //member x.BoxedValue =
        //    match x with
        //    | Int x -> box x
        //    | String x -> box x
        //    | TimeSpan x -> box x
        //    | Bool x -> box x
        //    | Uri x -> box x
        //    | Float x -> box x
    }    
        
    [Show]
    variant Node {
        | Scal { v: Scalar }
        | List { children: list[Node] }
        | Map { nodes: list[string * Node] }
    }
    
    module Builder {
        public Transform (name: option[string], node: Node): list[ClassMember] {
            match (name, node) {
            | (Some(name), Scal(x)) => TransformScalar(name, x)
            //| (_, Map(m)) => TransformMap(name, m)
            //| (Some(name), List(l)) => TransformList(name, true, l)
            | _ => []
            //| (None, _) => throw Exception("Only Maps are allowed at the root level.")
            }
        }
        
        TransformScalar(name: string, node: Scalar): list[ClassMember] {
            def rawType = node.UnderlyingType.FullName;
            def name = $"_$name";
            def field = <[decl: private $(name: usesite): $(rawType: usesite) ]>;
            //let prop = ProvidedProperty (name, rawType, IsStatic = false, GetterCode = (fun [me] -> Expr.FieldGet(me, field)))
            //if not readOnly then prop.SetterCode <- (fun [me;v] -> Expr.FieldSet(me, field, v))
            //let initValue = node.ToExpr()

            //{ MainType = Some rawType
            //  Types = [field :> MemberInfo; prop :> MemberInfo]
            //  Init = fun me -> Expr.FieldSet(me, field, initValue) }
            [field]
        }
    }
	
	module YamlImpl {
		public Transform(typer: Typer, typeName: PExpr, text: PExpr): PExpr {
		    match (typeName, text) {
		    | (<[ $(PExpr.Ref(typeName)) ]>, <[ $(PExpr.Literal(Literal.String(text))) ]>) => { 
                def serializer = Deserializer();
                def node = serializer.Deserialize(StringReader(text));
            
                def loop(n: object) {
                    match (n) {
                    | l is List[object] => Node.List (l.Map(loop))
                    | d is Dictionary[object, object] => 
                        Node.Map (d.NToList().Choose(p => {
                            match (p.Key) {
                            | key is string => Some(key, loop(p.Value))
                            | _ => None()
                            }}))
                    | scalar =>
                        Node.Scal (Scalar.FromObj(scalar))
                    }
                }
            
                def node = loop(node);
                def nodeAsString = node.ToString();
		        
                Util.locate(typeName.Location,
		        {
		            def astAsStringProp = <[ decl: public AstAsString: string { get { $nodeAsString }} ]>;
		            def members = astAsStringProp :: Builder.Transform(None(), node);
		            def builder = typer.Env.Define(<[ decl:
            		    public class $typeName {
            		        ..$members
            		    }
		                ]>);
		            builder.Compile();
		        });
		        <[]>
			  }
			| _ => Message.FatalError($"Name must be a symbol and text must be a string, but got $(typeName.GetType().ToString()), $(text.ToString())")
		    }
		}
	}
}
