using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.ActivePatterns;
using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using YamlDotNet;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.Serializer;
using Utils;
using Macros.Core;

namespace nYaml {
    [MacroUsage (MacroPhase.BeforeInheritance, MacroTargets.Assembly)]
	public macro Yaml(name: PExpr, text: PExpr)
	//syntax("yaml", name, "of", text)
	{
		def typer = Macros.ImplicitCTX();
		YamlImpl.Transform(typer, name, text);
	}
	
	[Show]
	variant Scalar {
	    | Int { v: int }
	    | String { v: string }
	    | TimeSpan { v: System.TimeSpan }
	    | Bool { v: bool; [RecordIgnore] foo: int }
	    | Uri { v: System.Uri }
	    | Float { v: double; }
    
        public static ParseStr(str: string): Scalar {
            active match (str) {
            | ValueParser.TimeSpan(x) => Scalar.TimeSpan(x)
            | ValueParser.Uri(x) => Scalar.Uri(x)
            | x => String(x)
            }
        }
        
	    public static FromObj(obj: object): Scalar {
	        match (obj) {
            | null => String("")
            | b is System.Boolean => Bool(b)
            | i is System.Int32 => Int(i)
            | d is System.Double => Float(d)
            | s is System.String => Scalar.ParseStr(s)
            | t => throw Exception($"Unknown type $(t.GetType().ToString())")
            }
        }
            
        public UnderlyingType: Type {
            get {
                match (this) {
                | Int(v) with x = v : object
                | String(x)
                | Bool(x)
                | TimeSpan(x)
                | Uri(x)
                | Float(x) => x.GetType()
                }
            }
        }
        //member x.BoxedValue =
        //    match x with
        //    | Int x -> box x
        //    | String x -> box x
        //    | TimeSpan x -> box x
        //    | Bool x -> box x
        //    | Uri x -> box x
        //    | Float x -> box x
    }    
        
    [Show]
    variant Node {
        | Scal { v: Scalar }
        | List { children: list[Node] }
        | Map { nodes: list[string * Node] }
    }
        
    module Builder {
        public Transform (builder: TypeBuilder, name: option[string], node: Node): void  {
            match (name, node) {
            | (Some(name), Scal(x)) => TransformScalar(builder, name, x)
            | (_, Map(m)) => TransformMap(builder, name, m)
            //| (Some(name), List(l)) => TransformList(name, true, l)
            | _ => ()
            //| (None, _) => throw Exception("Only Maps are allowed at the root level.")
            }
        }
        
        TransformScalar(builder: TypeBuilder, name: string, node: Scalar): void {
            def rawType = node.UnderlyingType.Name;
            def fieldName = $"_$name";
            builder.Define(<[decl: private mutable $(fieldName: usesite): $(rawType: usesite) ]>);
            builder.Define(<[decl: public $(name: usesite): $(rawType: usesite) { get { this.$(fieldName: usesite) } } ]>);
        }
        
        TransformChildren(builder: TypeBuilder, children: list[string * Node]): void {
            foreach ((name, child) in children)
                Transform(builder, Some(name), child);
        }
        
        TransformMap(builder: TypeBuilder, name: option[string], children: list[string * Node]): void {
            match (name) {
            | Some (name) =>
                def typeName = name + "_Type";
                def mapTy = builder.DefineNestedType(<[decl: public sealed class $(typeName: usesite) { } ]>);
                TransformChildren(mapTy, children);
                def mapFieldName = $"_$name";
                builder.Define(<[decl: private $(mapFieldName: usesite): $(mapTy.Name: usesite) = $(mapTy.Name: usesite)(); ]>);
                builder.Define(<[decl: public $(mapTy.Name: usesite): $(mapTy.Name: usesite) { get { this.$(mapFieldName: usesite) } } ]>);
            | None => 
                TransformChildren(builder, children)
            }
        }
    }
	
	module YamlImpl {
		public Transform(typer: Typer, typeName: PExpr, text: PExpr): PExpr {
		    match (typeName, text) {
		    | (<[ $(PExpr.Ref(typeName)) ]>, <[ $(text: string) ]>) => { 
                def serializer = Deserializer();
                def node = serializer.Deserialize(StringReader(text));
            
                def loop(n: object) {
                    match (n) {
                    | l is List[object] => Node.List (l.Map(loop))
                    | d is Dictionary[object, object] => 
                        Node.Map (d.NToList().Choose(p => {
                            match (p.Key) {
                            | key is string => Some(key, loop(p.Value))
                            | _ => None()
                            }}))
                    | scalar =>
                        Node.Scal (Scalar.FromObj(scalar))
                    }
                }
            
                def node = loop(node);
                def nodeAsString = node.ToString();
                Util.locate(typeName.Location,
		        {
		            def builder = typer.Env.Define(<[ decl: public sealed class $typeName {} ]>);
		            builder.Define(<[ decl: public AstAsString: string { get { $nodeAsString }} ]>);
		            Builder.Transform(builder, None(), node);
		            builder.Compile();
		        });
		        <[]>
			  }
			| _ => Message.FatalError($"Name must be a symbol and text must be a string, but got $(typeName.GetType().ToString()), $(text.ToString())")
		    }
		}
	}
	
	module Test {
	    x(): void {
            _ = 
                my match (2) {
                | 1 < x < 4 => x
                | 1 < x < 4 when x > 1 => x + 1
                | x when x > 10 => 1
                }
            mutable x;
            GetTypedInfo(x);
            
            _ = lock1 (array[1]) { 1 == 1 }
            
            x = List.[int](2);
	    }
	}
}
