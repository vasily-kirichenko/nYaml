using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.ActivePatterns;
using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using YamlDotNet;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.Serializer;

namespace nYaml
{
	public macro Yaml(text: string)
	{
		def typer = Macros.ImplicitCTX();
		YamlImpl.Transform(typer, text);
	}
	
	variant Scalar {
	    | Int { v: int }
	    | String { v: string }
	    | TimeSpan { v: TimeSpan }
	    | Bool { v: bool }
	    | Uri { v: Uri }
	    | Float { v: double }
    
        //public static ParseStr(str: string) {
        //    active match (str) {
        //    | ValueParser.TimeSpan(x) => TimeSpan(x)
        //    | ValueParser.Uri(x) => Uri(x)
        //    | x => String(x)
        //    }
        //}
        //static member FromObj : obj -> Scalar = function
        //    | null -> String ""
        //    | :? System.Boolean as b -> Bool b
        //    | :? System.Int32 as i -> Int i
        //    | :? System.Double as d -> Float d
        //    | :? System.String as s ->
        //        Scalar.ParseStr s
        //    |t -> failwithf "Unknown type %s" (string (t.GetType()))
        //member x.UnderlyingType = 
        //    match x with
        //    | Int x -> x.GetType()
        //    | String x -> x.GetType()
        //    | Bool x -> x.GetType()
        //    | TimeSpan x -> x.GetType()
        //    | Uri x -> x.GetType()
        //    | Float x -> x.GetType()
        //member x.BoxedValue =
        //    match x with
        //    | Int x -> box x
        //    | String x -> box x
        //    | TimeSpan x -> box x
        //    | Bool x -> box x
        //    | Uri x -> box x
        //    | Float x -> box x
    }    
        
    variant Node {
        | Scalar { v: Scalar }
        | List { children: list[Node] }
        | Map { nodes: list[string * Node] }
    }
	
	module YamlImpl {
		public Transform(typer: Typer, text: string): PExpr {
		    def settings = SerializationOptions();
            def serializer = Deserializer();
            def node = serializer.Deserialize(StringReader(text));
            
            def loop(n: object) {
                match (n) {
                | n is List<obj> as l => Node.List (l |> Seq.map loop |> Seq.toList)
                | :? Dictionary<obj,obj> as m -> 
                    Map (m |> Seq.choose (fun p -> 
                        match p.Key with
                        | :? string as key -> Some (key, loop p.Value)
                        | _ -> None) |> Seq.toList)
                | scalar ->
                    Scalar (Scalar.FromObj scalar)
                }
            }
		    
			<[ $text ]>
		}
	}
}
