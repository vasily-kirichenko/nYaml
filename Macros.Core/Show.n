using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler.Parsetree;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Macros.Core
{
    [MacroUsage(MacroPhase.WithTypedMembers, MacroTargets.Class, Inherited = false, AllowMultiple = false)]
    public macro Show(ty: TypeBuilder) {
        ShowImpl.Transform (ty)
    }

    module ShowImpl {
        public Transform(ty: TypeBuilder): void {
            match (ty) {
            | _ when ty.IsDelegate with n = "delegates"
            | _ when ty.IsEnum with n = "enums"
            | _ when ty.IsInterface with n = "interfaces"
            | _ when ty.IsModule with n = "modules" => 
                Message.Error(ty.Location, $"The Show macro does not support $n."); 
                <[]>
            | _ => {
                ty.GetVariantOptions().Iter(opt => {
                    def fields: list[IField] = opt.GetFields(BindingFlags.Public %| BindingFlags.Instance %| BindingFlags.DeclaredOnly);
                    def fieldsExpr: PExpr = fields.Fold(<[]>, (f, acc) => {
                         match (acc) {
                         | <[]> => <[ $(f.Name: usesite).ToString() ]>
                         | _ => <[ $acc + ", " + $(f.Name: usesite).ToString() ]>
                         }
                    });
                    
                    def body: PExpr =
                        match (fieldsExpr) {
                        | <[]> => <[ $(opt.Name) ]>
                        | _ => <[ $(opt.Name) + "(" + $fieldsExpr + ")" ]>
                        };
                           
                    opt.Define(<[decl:
                        public override ToString(): string {
                            $body
                        }
                        ]>);
                });
              }
            }
        }
    }
}
